python script.py < input.txt


!!!!! 어지간하면 터미널에서 실행시키자 !!!!!

주피터 노트북에서는 
----------------------------------------------
import os
s = b'아무 문자열'
os.write(1, s)
----------------------------------------------
의 결과가 '문자열의 길이'로 나온다 시발거

또한,

----------------------------------------------
import time

for i in range(10):
    print(i, end = ' ')
    time.sleep(1) 
----------------------------------------------
의 결과가
12345~가 10초 후에 한 번에 나오는 게 아니라
1 ... 2... 3... 이런 식으로 1초 간격 두고 나온다.
* end=

나 같은 경우에는 두 번째 현상(주피터 노트북과 터미널에서의 버퍼링 차이)

print("os.write(1, input2) : ", end='')
os.write(1, input2)

을 터미널에서 실행시켰을 때 os.write의 결과가 print보다 먼저 나오는 것을 보고 알아차렸다.

생각의 흐름

'말이 안 되는데? 설마 print가 비동기 함수였나?'
->
'아니야, 지금까지 print 쓰면서 그렇게 작용한 적이 없었는데. end=''를 한 상태에서 print 여러 개 써도 다 잘 순서대로 나왔잖아.'
->
'아, 비동기함수든 아니든 결국 지금까지 모든 결과를 print를 통해 가시적으로 확인했으니까, 같은 함수를 써왔던 거니까 기존의 경험을 근거 삼으면 안 되겠다.'
->
'그래서, end랑 이게 무슨 관련인거지'

이러다가 https://velog.io/@janeljs/python-print-sep-end-file-flush 블로그를 통해 이해하게 됨

이건 처음부터 터미널 환경에서 확인했기에 알아차릴 수 있었던 거지
주피터 노트북으로
print("os.write(1, input2) : ", end='')
os.write(1, input2)
을 돌렸으면 순서가 역전된 걸 알지도 못했을 거 아니야.
이런 현상에 대해서 알 기회가 없었을 거 아니야.

앞으로 어지간하면 터미널 환경에서 연습하는 습관을 들여야겠다.



----------------------

print('', seperator = '', end = '\n', file = 'sys.stdout', flush = False)


만약 write(string) 메서드가 포함된 파일 객체가 없다면, file의 초기값은 sys.stdout으로 설정되어 있다. stdout은 standard out(표준 출력)의 약자로 print()함수의 기본값은 화면에 내용을 출력하는 것으로 설정되어 있다는 뜻이다. (이는 우리 모두 이미 아는 내용이다.)


flush(clear)

print() 함수의 flush 매개변수는 출력 버퍼를 비우는 동작을 제어합니다. 기본적으로 flush 매개변수는 False로 설정되어 있으며, 이는 출력 버퍼가 가득 차거나 새 줄이 출력될 때만 버퍼가 비워짐을 의미합니다.

그러나 flush=True로 설정하면 print() 함수가 호출될 때마다 출력 버퍼를 강제로 비우게 됩니다. 이는 데이터를 즉시 화면에 표시하고자 할 때 사용됩니다.











완전 버퍼링 예제
완전 버퍼링을 직접 제어하려면 파일을 열 때 버퍼 크기를 설정할 수 있습니다:

with open('output.txt', 'w', buffering=1024) as f:
    for i in range(5):
        f.write(f"Line {i}\n")
        time.sleep(1)

이 예제에서 버퍼 크기를 1024바이트로 설정했습니다. 버퍼가 가득 차기 전에는 파일에 내용이 기록되지 않습니다.







비버퍼링 예제
표준 에러(stderr)는 기본적으로 비버퍼링입니다:

import sys
import time

for i in range(5):
    sys.stderr.write(f"Error Line {i}\n")
    time.sleep(1)

이 예제에서 sys.stderr.write는 즉시 출력되므로 각 줄이 바로 출력됩니다.



프로세스가 종료될 대도 버퍼 다 비우고(방출하고, 출력하고) 종료하는 듯